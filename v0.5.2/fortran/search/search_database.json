var tipuesearch = {"pages":[{"title":" vesin ","text":"vesin This is the API documentation for the Fortran bindings to vesin. We provide two modules: vesin which is the high-level interface and vesin_c which is a direct translation of the C API. For the high-level\ninterface, everything is handled by the NeighborList type, which holds\noptions, runs the calculations and holds the data afterward. Example usage program main use vesin , only : NeighborList implicit none real , allocatable :: positions (:,:) real :: box ( 3 , 3 ) integer :: i , ierr type ( NeighborList ) :: neighbor_list ! we have 2000 points in this example allocate ( positions ( 3 , 2000 )) ! set the values for points `positions` and bounding `box` here ! positions = ... ! box = ... ! initialize `neighbor_list` with some options neighbor_list = NeighborList ( cutoff = 4.2 , full = . true ., sorted = . true .) ! run the calculation call neighbor_list % compute ( positions , box , periodic = . true ., status = ierr ) if ( ierr /= 0 ) then write ( * , * ) neighbor_list % errmsg stop end if write ( * , * ) \"we got \" , neighbor_list % length , \"pairs\" do i = 1 , neighbor_list % length write ( * , * ) \" - \" , i , \":\" , neighbor_list % pairs (:, i ) end do ! release allocated memory call neighbor_list % free () deallocate ( positions ) end program main","tags":"home","url":"index.html"},{"title":"NeighborList – vesin ","text":"type, public :: NeighborList A neighbor list calculator. This type contains pointers to the computed C data, in C precision. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: errmsg Latest error message integer(kind=c_size_t), public :: length = 0_c_size_t Number of pairs in the list integer(kind=c_size_t), public, pointer :: pairs (:,:) => null() Array of pairs (storing the indices of the first and second point in\nthe pair). The shape is [2, length] . integer(kind=c_int32_t), public, pointer :: shifts (:,:) => null() Array of box shifts, one for each pair . This is only set if return_pairs was set to .true. during intialization. The shape\nis [3, length] real(kind=c_double), public, pointer :: distances (:) => null() Array of pair distance (i.e. distance between the two points), one\nfor each pair . This is only set if return_distances was set to .true. during intialization. The shape is [length] real(kind=c_double), public, pointer :: vectors (:,:) => null() Array of pair vector (i.e. vector between the two points), one\nfor each pair . This is only set if return_vectors was set to .true. during intialization. The shape is [3, length] Constructor public        interface NeighborList Initialize a NeighborList . The cutoff and full options are mandatory, the other are optional\nand default to .false. private  function vesin_construct_c_float(cutoff, full, sorted, algorithm, return_shifts, return_distances, return_vectors) result(self) Arguments Type Intent Optional Attributes Name real(kind=c_float), intent(in) :: cutoff Spherical cutoff, only pairs below this cutoff will be included logical, intent(in) :: full Should the returned neighbor list be a full list (include both i -> j and j -> i pairs) or a half list (include only i -> j )? logical, intent(in), optional :: sorted Should the neighbor list be sorted? If yes, the returned pairs will be\nsorted using lexicographic order. integer(kind=c_int32_t), intent(in), optional :: algorithm Algorithm to use for the neighbor list calculation (one of VesinAutoAlgorithm , ! VesinBruteForceAlgorithm , or VesinCellListAlgorithm ) logical, intent(in), optional :: return_shifts Should the returned VesinNeighborList contain shifts ? logical, intent(in), optional :: return_distances Should the returned VesinNeighborList contain distances ? logical, intent(in), optional :: return_vectors Should the returned VesinNeighborList contain vector ? Return Value type( NeighborList ) private  function vesin_construct_c_double(cutoff, full, sorted, algorithm, return_shifts, return_distances, return_vectors) result(self) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: cutoff Spherical cutoff, only pairs below this cutoff will be included logical, intent(in) :: full Should the returned neighbor list be a full list (include both i -> j and j -> i pairs) or a half list (include only i -> j )? logical, intent(in), optional :: sorted Should the neighbor list be sorted? If yes, the returned pairs will be\nsorted using lexicographic order. integer(kind=c_int32_t), intent(in), optional :: algorithm Algorithm to use for the neighbor list calculation (one of VesinAutoAlgorithm , ! VesinBruteForceAlgorithm , or VesinCellListAlgorithm ) logical, intent(in), optional :: return_shifts Should the returned VesinNeighborList contain shifts ? logical, intent(in), optional :: return_distances Should the returned VesinNeighborList contain distances ? logical, intent(in), optional :: return_vectors Should the returned VesinNeighborList contain vector ? Return Value type( NeighborList ) Type-Bound Procedures generic, public :: compute => vesin_compute_c_double private  subroutine vesin_compute_c_double(self, points, box, periodic, status) Compute the neighbor list for data in c_double / real64 precision Arguments Type Intent Optional Attributes Name class( NeighborList ), intent(inout) :: self The neighbor list calculator real(kind=c_double), intent(in) :: points (:,:) Positions of all points to consider, this must be a 3 x n_points array. real(kind=c_double), intent(in) :: box (3,3) Bounding box for the system. If the system is non-periodic,\nthis is ignored. This should contain the three vectors of the\nbounding box, one vector per column of the matrix. logical, intent(in) :: periodic (3) Is the system using periodic boundary conditions? This\nshould be an array of three logical, one for each dimension. integer, optional :: status Status code of the operation, this will be 0 if there are no error,\nand non-zero otherwise. The full error message will be stored in self%errmsg . generic, public :: compute => vesin_compute_c_float private  subroutine vesin_compute_c_float(self, points, box, periodic, status) Compute the neighbor list for data in c_float / real32 precision Arguments Type Intent Optional Attributes Name class( NeighborList ), intent(inout) :: self The neighbor list calculator real(kind=c_float), intent(in) :: points (:,:) Positions of all points to consider, this must be a 3 x n_points array. real(kind=c_float), intent(in) :: box (3,3) Bounding box for the system. If the system is non-periodic,\nthis is ignored. This should contain the three vectors of the\nbounding box, one vector per column of the matrix. logical, intent(in) :: periodic (3) Is the system using periodic boundary conditions? This\nshould be an array of three booleans, one for each dimension. integer, optional :: status Status code of the operation, this will be 0 if there are no error,\nand non-zero otherwise. The full error message will be stored in self%errmsg . procedure, public :: free => vesin_destroy private  subroutine vesin_destroy(self) Release all data allocated on the C side, and reset the NeighborList . This function should be called when you no longer need the data. Arguments Type Intent Optional Attributes Name class( NeighborList ), intent(inout) :: self The neighbor list calculator","tags":"","url":"type/neighborlist.html"},{"title":"VesinDevice – vesin ","text":"type, public, bind(c) :: VesinDevice Device on which data can be allocated Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: type = VesinUnknownDevice Device type (VesinUnknownDevice, VesinCPU, etc.) integer(kind=c_int), public :: device_id = 0 Device index (0 for CPU, GPU index for CUDA)","tags":"","url":"type/vesindevice.html"},{"title":"VesinOptions – vesin ","text":"type, public, bind(c) :: VesinOptions Used for storing Vesin options. Components Type Visibility Attributes Name Initial real(kind=c_double), public :: cutoff = 0.0_c_double Spherical cutoff, only pairs below this cutoff will be included logical(kind=c_bool), public :: full Should the returned neighbor list be a full list (include both i -> j and j -> i pairs) or a half list (include only i -> j )? logical(kind=c_bool), public :: sorted = .false. Should the neighbor list be sorted? If yes, the returned pairs will be\nsorted using lexicographic order. integer(kind=c_int), public :: algorithm = VesinAutoAlgorithm Which algorithm to use for the calculation logical(kind=c_bool), public :: return_shifts = .false. Should the returned VesinNeighborList contain shifts ? logical(kind=c_bool), public :: return_distances = .false. Should the returned VesinNeighborList contain distances ? logical(kind=c_bool), public :: return_vectors = .false. Should the returned VesinNeighborList contain vector ?","tags":"","url":"type/vesinoptions.html"},{"title":"VesinNeighborList – vesin ","text":"type, public, bind(c) :: VesinNeighborList Used as return type from vesin_neighbors() . Data is returned in the various type(c_ptr) pointers to memory allocated\nby C. They need to be transformed into fortran pointers in order to read\nthe values. Components Type Visibility Attributes Name Initial integer(kind=c_size_t), public :: length = 0_c_size_t Number of pairs in this neighbor list type( VesinDevice ), public :: device Device used for the data allocations type(c_ptr), public :: pairs = c_null_ptr Array of pairs (storing the indices of the first and second point in\nthe pair), containing length elements. type(c_ptr), public :: shifts = c_null_ptr Array of box shifts, one for each pair . This is only set if options.return_pairs was true during the calculation. type(c_ptr), public :: distances = c_null_ptr Array of pair distance (i.e. distance between the two points), one for\neach pair. This is only set if options.return_distances was true during the calculation. type(c_ptr), public :: vectors = c_null_ptr Array of pair vector (i.e. vector between the two points), one for\neach pair. This is only set if options.return_vector was true during the calculation. type(c_ptr), public :: opaque = c_null_ptr Private pointer used to hold additional internal data","tags":"","url":"type/vesinneighborlist.html"},{"title":"NeighborList – vesin","text":"public interface NeighborList Initialize a NeighborList . The cutoff and full options are mandatory, the other are optional\nand default to .false. Module Procedures private  function vesin_construct_c_float(cutoff, full, sorted, algorithm, return_shifts, return_distances, return_vectors) result(self) Arguments Type Intent Optional Attributes Name real(kind=c_float), intent(in) :: cutoff Spherical cutoff, only pairs below this cutoff will be included logical, intent(in) :: full Should the returned neighbor list be a full list (include both i -> j and j -> i pairs) or a half list (include only i -> j )? logical, intent(in), optional :: sorted Should the neighbor list be sorted? If yes, the returned pairs will be\nsorted using lexicographic order. integer(kind=c_int32_t), intent(in), optional :: algorithm Algorithm to use for the neighbor list calculation (one of VesinAutoAlgorithm , ! VesinBruteForceAlgorithm , or VesinCellListAlgorithm ) logical, intent(in), optional :: return_shifts Should the returned VesinNeighborList contain shifts ? logical, intent(in), optional :: return_distances Should the returned VesinNeighborList contain distances ? logical, intent(in), optional :: return_vectors Should the returned VesinNeighborList contain vector ? Return Value type( NeighborList ) private  function vesin_construct_c_double(cutoff, full, sorted, algorithm, return_shifts, return_distances, return_vectors) result(self) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: cutoff Spherical cutoff, only pairs below this cutoff will be included logical, intent(in) :: full Should the returned neighbor list be a full list (include both i -> j and j -> i pairs) or a half list (include only i -> j )? logical, intent(in), optional :: sorted Should the neighbor list be sorted? If yes, the returned pairs will be\nsorted using lexicographic order. integer(kind=c_int32_t), intent(in), optional :: algorithm Algorithm to use for the neighbor list calculation (one of VesinAutoAlgorithm , ! VesinBruteForceAlgorithm , or VesinCellListAlgorithm ) logical, intent(in), optional :: return_shifts Should the returned VesinNeighborList contain shifts ? logical, intent(in), optional :: return_distances Should the returned VesinNeighborList contain distances ? logical, intent(in), optional :: return_vectors Should the returned VesinNeighborList contain vector ? Return Value type( NeighborList )","tags":"","url":"interface/neighborlist.html"},{"title":"vesin_neighbors – vesin","text":"interface Compute a neighbor list. The data is returned in a VesinNeighborList . For an initial call, the VesinNeighborList should be default-initalized. The VesinNeighborList can be re-used across calls to this functions to re-use memory allocations,\nand once it is no longer needed, users should call vesin_free to\nrelease the corresponding memory. public  function vesin_neighbors(points, n_points, box, periodic, device, options, neighbors, error_message) result(status) bind(c, name=\"vesin_neighbors\") Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: points (3,n_points) Positions of all points in the system; integer(kind=c_size_t), value :: n_points Number of elements in the points array real(kind=c_double), intent(in) :: box (3,3) Bounding box for the system. If the system is non-periodic,\nthis is ignored. This should contain the three vectors of the\nbounding box, one vector per column of the matrix. logical(kind=c_bool) :: periodic (3) Is the system using periodic boundary conditions? This\nshould be an array of three booleans, one for each dimension. type( VesinDevice ), value :: device Device where the points and box data is allocated. type( VesinOptions ), value :: options Options for the calculation type( VesinNeighborList ) :: neighbors A type(VesinNeighborList) instance, that will be used\nto store the computed list of neighbors. type(c_ptr), intent(in) :: error_message A type(c_ptr) to a null-terminated char* containing the\nerror message of this function if any. Return Value integer(kind=c_int) Non-zero integer upon error; zero otherwise.","tags":"","url":"interface/vesin_neighbors.html"},{"title":"vesin_free – vesin","text":"interface Free all allocated memory inside a VesinNeighborList , according to it's device . public  subroutine vesin_free(neighbors) bind(C, name=\"vesin_free\") Arguments Type Intent Optional Attributes Name type( VesinNeighborList ) :: neighbors","tags":"","url":"interface/vesin_free.html"},{"title":"vesin – vesin","text":"High-level fortran interface to vesin. This is the recomended interface to vesin, taking care of data conversion\nfrom and to the C API for you. Uses vesin_c iso_c_binding Interfaces public        interface NeighborList Initialize a NeighborList . The cutoff and full options are mandatory, the other are optional\nand default to .false. private  function vesin_construct_c_float(cutoff, full, sorted, algorithm, return_shifts, return_distances, return_vectors) result(self) Arguments Type Intent Optional Attributes Name real(kind=c_float), intent(in) :: cutoff Spherical cutoff, only pairs below this cutoff will be included logical, intent(in) :: full Should the returned neighbor list be a full list (include both i -> j and j -> i pairs) or a half list (include only i -> j )? logical, intent(in), optional :: sorted Should the neighbor list be sorted? If yes, the returned pairs will be\nsorted using lexicographic order. integer(kind=c_int32_t), intent(in), optional :: algorithm Algorithm to use for the neighbor list calculation (one of VesinAutoAlgorithm , ! VesinBruteForceAlgorithm , or VesinCellListAlgorithm ) logical, intent(in), optional :: return_shifts Should the returned VesinNeighborList contain shifts ? logical, intent(in), optional :: return_distances Should the returned VesinNeighborList contain distances ? logical, intent(in), optional :: return_vectors Should the returned VesinNeighborList contain vector ? Return Value type( NeighborList ) private  function vesin_construct_c_double(cutoff, full, sorted, algorithm, return_shifts, return_distances, return_vectors) result(self) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: cutoff Spherical cutoff, only pairs below this cutoff will be included logical, intent(in) :: full Should the returned neighbor list be a full list (include both i -> j and j -> i pairs) or a half list (include only i -> j )? logical, intent(in), optional :: sorted Should the neighbor list be sorted? If yes, the returned pairs will be\nsorted using lexicographic order. integer(kind=c_int32_t), intent(in), optional :: algorithm Algorithm to use for the neighbor list calculation (one of VesinAutoAlgorithm , ! VesinBruteForceAlgorithm , or VesinCellListAlgorithm ) logical, intent(in), optional :: return_shifts Should the returned VesinNeighborList contain shifts ? logical, intent(in), optional :: return_distances Should the returned VesinNeighborList contain distances ? logical, intent(in), optional :: return_vectors Should the returned VesinNeighborList contain vector ? Return Value type( NeighborList ) Derived Types type, public :: NeighborList A neighbor list calculator. Read more… Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: errmsg Latest error message integer(kind=c_size_t), public :: length = 0_c_size_t Number of pairs in the list integer(kind=c_size_t), public, pointer :: pairs (:,:) => null() Array of pairs (storing the indices of the first and second point in\nthe pair). The shape is [2, length] . integer(kind=c_int32_t), public, pointer :: shifts (:,:) => null() Array of box shifts, one for each pair . This is only set if return_pairs was set to .true. during intialization. The shape\nis [3, length] real(kind=c_double), public, pointer :: distances (:) => null() Array of pair distance (i.e. distance between the two points), one\nfor each pair . This is only set if return_distances was set to .true. during intialization. The shape is [length] real(kind=c_double), public, pointer :: vectors (:,:) => null() Array of pair vector (i.e. vector between the two points), one\nfor each pair . This is only set if return_vectors was set to .true. during intialization. The shape is [3, length] Constructor Initialize a NeighborList . Read more… private\n\n                    \n                    function vesin_construct_c_float (cutoff, full, sorted, algorithm, return_shifts, return_distances, return_vectors) private\n\n                    \n                    function vesin_construct_c_double (cutoff, full, sorted, algorithm, return_shifts, return_distances, return_vectors) Type-Bound Procedures generic, public :: compute => vesin_compute_c_double generic, public :: compute => vesin_compute_c_float procedure, public :: free => vesin_destroy","tags":"","url":"module/vesin.html"},{"title":"vesin_c – vesin","text":"This is a Fortran interface to the C-API of vesin , from the header vesin.h . Uses iso_c_binding Enumerations enum, bind(c) Enumerators enumerator :: VesinUnknownDevice = 0 Unknown device, used for default initialization and to indicate no\nallocated data. enumerator :: VesinCPU = 1 CPU device enumerator :: VesinCUDA = 2 CPU device Description Device type on which the data can be enum, bind(c) Enumerators enumerator :: VesinAutoAlgorithm = 0 Automatically select algorithm based on system size enumerator :: VesinBruteForce = 1 Brute-force O(n&#94;2) algorithm with minimum image convention enumerator :: VesinCellList = 2 Cell list algorithm with O(n) scaling Description Algorithm to use for neighbor list construction Interfaces interface Compute a neighbor list. The data is returned in a VesinNeighborList . For an initial call, the VesinNeighborList should be default-initalized. The VesinNeighborList can be re-used across calls to this functions to re-use memory allocations,\nand once it is no longer needed, users should call vesin_free to\nrelease the corresponding memory. public  function vesin_neighbors(points, n_points, box, periodic, device, options, neighbors, error_message) result(status) bind(c, name=\"vesin_neighbors\") Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(in) :: points (3,n_points) Positions of all points in the system; integer(kind=c_size_t), value :: n_points Number of elements in the points array real(kind=c_double), intent(in) :: box (3,3) Bounding box for the system. If the system is non-periodic,\nthis is ignored. This should contain the three vectors of the\nbounding box, one vector per column of the matrix. logical(kind=c_bool) :: periodic (3) Is the system using periodic boundary conditions? This\nshould be an array of three booleans, one for each dimension. type( VesinDevice ), value :: device Device where the points and box data is allocated. type( VesinOptions ), value :: options Options for the calculation type( VesinNeighborList ) :: neighbors A type(VesinNeighborList) instance, that will be used\nto store the computed list of neighbors. type(c_ptr), intent(in) :: error_message A type(c_ptr) to a null-terminated char* containing the\nerror message of this function if any. Return Value integer(kind=c_int) Non-zero integer upon error; zero otherwise. interface Free all allocated memory inside a VesinNeighborList , according to it's device . public  subroutine vesin_free(neighbors) bind(C, name=\"vesin_free\") Arguments Type Intent Optional Attributes Name type( VesinNeighborList ) :: neighbors Derived Types type, public, bind(c) :: VesinDevice Device on which data can be allocated Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: type = VesinUnknownDevice Device type (VesinUnknownDevice, VesinCPU, etc.) integer(kind=c_int), public :: device_id = 0 Device index (0 for CPU, GPU index for CUDA) type, public, bind(c) :: VesinOptions Used for storing Vesin options. Components Type Visibility Attributes Name Initial real(kind=c_double), public :: cutoff = 0.0_c_double Spherical cutoff, only pairs below this cutoff will be included logical(kind=c_bool), public :: full Should the returned neighbor list be a full list (include both i -> j and j -> i pairs) or a half list (include only i -> j )? logical(kind=c_bool), public :: sorted = .false. Should the neighbor list be sorted? If yes, the returned pairs will be\nsorted using lexicographic order. integer(kind=c_int), public :: algorithm = VesinAutoAlgorithm Which algorithm to use for the calculation logical(kind=c_bool), public :: return_shifts = .false. Should the returned VesinNeighborList contain shifts ? logical(kind=c_bool), public :: return_distances = .false. Should the returned VesinNeighborList contain distances ? logical(kind=c_bool), public :: return_vectors = .false. Should the returned VesinNeighborList contain vector ? type, public, bind(c) :: VesinNeighborList Used as return type from vesin_neighbors() . Read more… Components Type Visibility Attributes Name Initial integer(kind=c_size_t), public :: length = 0_c_size_t Number of pairs in this neighbor list type( VesinDevice ), public :: device Device used for the data allocations type(c_ptr), public :: pairs = c_null_ptr Array of pairs (storing the indices of the first and second point in\nthe pair), containing length elements. type(c_ptr), public :: shifts = c_null_ptr Array of box shifts, one for each pair . This is only set if options.return_pairs was true during the calculation. type(c_ptr), public :: distances = c_null_ptr Array of pair distance (i.e. distance between the two points), one for\neach pair. This is only set if options.return_distances was true during the calculation. type(c_ptr), public :: vectors = c_null_ptr Array of pair vector (i.e. vector between the two points), one for\neach pair. This is only set if options.return_vector was true during the calculation. type(c_ptr), public :: opaque = c_null_ptr Private pointer used to hold additional internal data","tags":"","url":"module/vesin_c.html"},{"title":"vesin.f90 – vesin","text":"Source Code !> High-level fortran interface to vesin. !! !! This is the recomended interface to vesin, taking care of data conversion !! from and to the C API for you. module vesin use , intrinsic :: iso_c_binding use vesin_c , only : VesinOptions , VesinNeighborList , VesinDevice , & vesin_neighbors , vesin_free , & VesinUnknownDevice , VesinCPU , VesinCUDA , & VesinAutoAlgorithm , VesinBruteForce , VesinCellList implicit none private public :: NeighborList ! mark everything from vesin_c private private :: VesinOptions , VesinNeighborList , vesin_neighbors , vesin_free ! Except the things that a user could need public :: VesinAutoAlgorithm , VesinBruteForce , VesinCellList public :: VesinDevice , VesinUnknownDevice , VesinCPU , VesinCUDA !> A neighbor list calculator. !! !! This type contains pointers to the computed C data, in C precision. type :: NeighborList !> .true. when instance has been initialized logical , private :: initialized = . false . !> Options for the calculation type ( VesinOptions ), private :: options !> The C struct holding neighbor data type ( VesinNeighborList ), private :: c_neighbors !> Latest error message character (:), allocatable :: errmsg !> Number of pairs in the list integer ( c_size_t ) :: length = 0_c_size_t !> Array of pairs (storing the indices of the first and second point in !! the pair). The shape is `[2, length]`. integer ( c_size_t ), pointer :: pairs (:,:) => null () !> Array of box shifts, one for each `pair`. This is only set if !! `return_pairs` was set to `.true.` during intialization. The shape !! is `[3, length]` integer ( c_int32_t ), pointer :: shifts (:,:) => null () !> Array of pair distance (i.e. distance between the two points), one !! for each `pair`. This is only set if `return_distances` was set to !! `.true.` during intialization. The shape is `[length]` real ( c_double ), pointer :: distances (:) => null () !> Array of pair vector (i.e. vector between the two points), one !! for each `pair`. This is only set if `return_vectors` was set to !! `.true.` during intialization. The shape is `[3, length]` real ( c_double ), pointer :: vectors (:, :) => null () contains procedure , private :: vesin_compute_c_double procedure , private :: vesin_compute_c_float generic , public :: compute => vesin_compute_c_double generic , public :: compute => vesin_compute_c_float procedure , public :: free => vesin_destroy end type NeighborList !> Initialize a `NeighborList`. !! !! The `cutoff` and `full` options are mandatory, the other are optional !! and default to `.false.` interface NeighborList procedure :: vesin_construct_c_float procedure :: vesin_construct_c_double end interface NeighborList contains function vesin_construct_c_double ( cutoff , full , sorted , algorithm , return_shifts , return_distances , return_vectors ) result ( self ) !> Spherical cutoff, only pairs below this cutoff will be included real ( c_double ), intent ( in ) :: cutoff !> Should the returned neighbor list be a full list (include both `i -> j` !! and `j -> i` pairs) or a half list (include only `i -> j`)? logical , intent ( in ) :: full !> Should the neighbor list be sorted? If yes, the returned pairs will be !! sorted using lexicographic order. logical , intent ( in ), optional :: sorted !> Algorithm to use for the neighbor list calculation (one of !! `VesinAutoAlgorithm`, ! `VesinBruteForceAlgorithm`, or !! `VesinCellListAlgorithm`) integer ( c_int32_t ), intent ( in ), optional :: algorithm !> Should the returned `VesinNeighborList` contain `shifts`? logical , intent ( in ), optional :: return_shifts !> Should the returned `VesinNeighborList` contain `distances`? logical , intent ( in ), optional :: return_distances !> Should the returned `VesinNeighborList` contain `vector`? logical , intent ( in ), optional :: return_vectors type ( neighborlist ) :: self self % options % cutoff = cutoff self % options % full = full if ( present ( sorted )) self % options % sorted = sorted if ( present ( algorithm )) self % options % algorithm = algorithm if ( present ( return_shifts )) self % options % return_shifts = return_shifts if ( present ( return_distances )) self % options % return_distances = return_distances if ( present ( return_vectors )) self % options % return_vectors = return_vectors self % initialized = . true . end function vesin_construct_c_double function vesin_construct_c_float ( cutoff , full , sorted , algorithm , return_shifts , return_distances , return_vectors ) result ( self ) !> Spherical cutoff, only pairs below this cutoff will be included real ( c_float ), intent ( in ) :: cutoff !> Should the returned neighbor list be a full list (include both `i -> j` !! and `j -> i` pairs) or a half list (include only `i -> j`)? logical , intent ( in ) :: full !> Should the neighbor list be sorted? If yes, the returned pairs will be !! sorted using lexicographic order. logical , intent ( in ), optional :: sorted !> Algorithm to use for the neighbor list calculation (one of !! `VesinAutoAlgorithm`, ! `VesinBruteForceAlgorithm`, or !! `VesinCellListAlgorithm`) integer ( c_int32_t ), intent ( in ), optional :: algorithm !> Should the returned `VesinNeighborList` contain `shifts`? logical , intent ( in ), optional :: return_shifts !> Should the returned `VesinNeighborList` contain `distances`? logical , intent ( in ), optional :: return_distances !> Should the returned `VesinNeighborList` contain `vector`? logical , intent ( in ), optional :: return_vectors type ( neighborlist ) :: self self = vesin_construct_c_double ( & real ( cutoff , c_double ), & full , & sorted , & algorithm , & return_shifts , & return_distances , & return_vectors & ) end function vesin_construct_c_float !> Compute the neighbor list for data in `c_double`/`real64` precision subroutine vesin_compute_c_double ( self , points , box , periodic , status ) implicit none !> The neighbor list calculator class ( NeighborList ), intent ( inout ) :: self !> Positions of all points to consider, this must be a `3 x n_points` !! array. real ( c_double ), intent ( in ) :: points (:, :) !> Bounding box for the system. If the system is non-periodic, !! this is ignored. This should contain the three vectors of the !! bounding box, one vector per column of the matrix. real ( c_double ), intent ( in ) :: box ( 3 , 3 ) !> Is the system using periodic boundary conditions? This !! should be an array of three logical, one for each dimension. logical , intent ( in ) :: periodic ( 3 ) !> Status code of the operation, this will be 0 if there are no error, !! and non-zero otherwise. The full error message will be stored in !! `self%errmsg`. integer , optional :: status integer :: points_shape ( 2 ) logical ( c_bool ) :: c_periodic ( 3 ) type ( c_ptr ) :: c_errmsg = c_null_ptr self % errmsg = \"\" if (. not . self % initialized ) then self % errmsg = \"NeighborList has to be initialized before calling compute\" status = - 1 return end if c_periodic = periodic points_shape = shape ( points ) if ( points_shape ( 1 ) /= 3 ) then self % errmsg = \"`points` should be a [3, n_points] array\" status = - 1 return end if status = int ( vesin_neighbors ( & points , & int ( points_shape ( 2 ), c_size_t ), & box , & c_periodic , & VesinDevice ( VesinCPU , 0 ), & self % options , & self % c_neighbors , & c_errmsg & )) if ( status /= 0 ) then self % errmsg = c2f_string ( c_errmsg ) return end if self % length = self % c_neighbors % length ! reset all data in self if ( associated ( self % pairs )) nullify ( self % pairs ) if ( associated ( self % shifts )) nullify ( self % shifts ) if ( associated ( self % distances )) nullify ( self % distances ) if ( associated ( self % vectors )) nullify ( self % vectors ) if ( c_associated ( self % c_neighbors % pairs )) then call c_f_pointer ( self % c_neighbors % pairs , self % pairs , shape = [ 2 , int ( self % length )]) endif if ( c_associated ( self % c_neighbors % shifts )) then call c_f_pointer ( self % c_neighbors % shifts , self % shifts , shape = [ 3 , int ( self % length )]) endif if ( c_associated ( self % c_neighbors % distances )) then call c_f_pointer ( self % c_neighbors % distances , self % distances , shape = [ int ( self % length )]) endif if ( c_associated ( self % c_neighbors % vectors )) then call c_f_pointer ( self % c_neighbors % vectors , self % vectors , shape = [ 3 , int ( self % length )]) endif end subroutine vesin_compute_c_double !> Compute the neighbor list for data in `c_float`/`real32` precision subroutine vesin_compute_c_float ( self , points , box , periodic , status ) implicit none !> The neighbor list calculator class ( NeighborList ), intent ( inout ) :: self !> Positions of all points to consider, this must be a `3 x n_points` !! array. real ( c_float ), intent ( in ) :: points (:, :) !> Bounding box for the system. If the system is non-periodic, !! this is ignored. This should contain the three vectors of the !! bounding box, one vector per column of the matrix. real ( c_float ), intent ( in ) :: box ( 3 , 3 ) !> Is the system using periodic boundary conditions? This !! should be an array of three booleans, one for each dimension. logical , intent ( in ) :: periodic ( 3 ) !> Status code of the operation, this will be 0 if there are no error, !! and non-zero otherwise. The full error message will be stored in !! `self%errmsg`. integer , optional :: status call vesin_compute_c_double ( self , real ( points , c_double ), real ( box , c_double ), periodic , status ) end subroutine vesin_compute_c_float !> Release all data allocated on the C side, and reset the `NeighborList`. !! !! This function should be called when you no longer need the data. subroutine vesin_destroy ( self ) !> The neighbor list calculator class ( NeighborList ), intent ( inout ) :: self if ( associated ( self % pairs )) nullify ( self % pairs ) if ( associated ( self % shifts )) nullify ( self % shifts ) if ( associated ( self % distances )) nullify ( self % distances ) if ( associated ( self % vectors )) nullify ( self % vectors ) call vesin_free ( self % c_neighbors ) self % initialized = . false . end subroutine vesin_destroy ! transform `type(c_ptr)` string to fortran `character(:),allocatable` string function c2f_string ( ptr ) result ( f_string ) implicit none interface function c_strlen ( str ) bind ( c , name = 'strlen' ) use iso_c_binding , only : c_ptr , c_size_t implicit none type ( c_ptr ), intent ( in ), value :: str integer ( c_size_t ) :: c_strlen end function c_strlen end interface type ( c_ptr ), intent ( in ) :: ptr character ( len = :), allocatable :: f_string character ( len = 1 , kind = c_char ), dimension (:), pointer :: c_string integer :: n , i if (. not . c_associated ( ptr )) then f_string = ' ' else n = int ( c_strlen ( ptr ), kind = kind ( n )) call c_f_pointer ( ptr , c_string , [ n + 1 ]) allocate ( character ( len = n ) :: f_string ) do i = 1 , n f_string ( i : i ) = c_string ( i ) end do end if end function c2f_string end module vesin","tags":"","url":"sourcefile/vesin.f90.html"},{"title":"cdef.f90 – vesin","text":"Source Code !> This is a Fortran interface to the C-API of `vesin`, from the header `vesin.h`. module vesin_c use , intrinsic :: iso_c_binding implicit none private public :: VesinUnknownDevice , VesinCPU , VesinCUDA public :: VesinAutoAlgorithm , VesinBruteForce , VesinCellList public :: VesinDevice public :: VesinOptions public :: VesinNeighborList public :: vesin_neighbors public :: vesin_free !> Device type on which the data can be enum , bind ( c ) !> Unknown device, used for default initialization and to indicate no !! allocated data. enumerator :: VesinUnknownDevice = 0 !> CPU device enumerator :: VesinCPU = 1 !> CPU device enumerator :: VesinCUDA = 2 end enum !> Algorithm to use for neighbor list construction enum , bind ( c ) !> Automatically select algorithm based on system size enumerator :: VesinAutoAlgorithm = 0 !> Brute-force O(n&#94;2) algorithm with minimum image convention enumerator :: VesinBruteForce = 1 !> Cell list algorithm with O(n) scaling enumerator :: VesinCellList = 2 end enum !> Device on which data can be allocated type , bind ( c ) :: VesinDevice !> Device type (VesinUnknownDevice, VesinCPU, etc.) integer ( c_int ) :: type = VesinUnknownDevice !> Device index (0 for CPU, GPU index for CUDA) integer ( c_int ) :: device_id = 0 end type VesinDevice !> Used for storing Vesin options. type , bind ( c ) :: VesinOptions !> Spherical cutoff, only pairs below this cutoff will be included real ( c_double ) :: cutoff = 0.0_c_double !> Should the returned neighbor list be a full list (include both `i -> j` !! and `j -> i` pairs) or a half list (include only `i -> j`)? logical ( c_bool ) :: full !> Should the neighbor list be sorted? If yes, the returned pairs will be !! sorted using lexicographic order. logical ( c_bool ) :: sorted = . false . !> Which algorithm to use for the calculation integer ( c_int ) :: algorithm = VesinAutoAlgorithm !> Should the returned `VesinNeighborList` contain `shifts`? logical ( c_bool ) :: return_shifts = . false . !> Should the returned `VesinNeighborList` contain `distances`? logical ( c_bool ) :: return_distances = . false . !> Should the returned `VesinNeighborList` contain `vector`? logical ( c_bool ) :: return_vectors = . false . end type VesinOptions !> Used as return type from `vesin_neighbors()`. !! !! Data is returned in the various `type(c_ptr)` pointers to memory allocated !! by C. They need to be transformed into fortran pointers in order to read !! the values. type , bind ( c ) :: VesinNeighborList !> Number of pairs in this neighbor list integer ( c_size_t ) :: length = 0_c_size_t !> Device used for the data allocations type ( VesinDevice ) :: device !> Array of pairs (storing the indices of the first and second point in !! the pair), containing `length` elements. type ( c_ptr ) :: pairs = c_null_ptr !> Array of box shifts, one for each `pair`. This is only set if !! `options.return_pairs` was `true` during the calculation. type ( c_ptr ) :: shifts = c_null_ptr !> Array of pair distance (i.e. distance between the two points), one for !! each pair. This is only set if `options.return_distances` was `true` !! during the calculation. type ( c_ptr ) :: distances = c_null_ptr !> Array of pair vector (i.e. vector between the two points), one for !! each pair. This is only set if `options.return_vector` was `true` !! during the calculation. type ( c_ptr ) :: vectors = c_null_ptr !> Private pointer used to hold additional internal data type ( c_ptr ) :: opaque = c_null_ptr end type VesinNeighborList !> Compute a neighbor list. !! !! The data is returned in a `VesinNeighborList`. For an initial call, the !! `VesinNeighborList` should be default-initalized. The `VesinNeighborList` !! can be re-used across calls to this functions to re-use memory allocations, !! and once it is no longer needed, users should call `vesin_free` to !! release the corresponding memory. interface function vesin_neighbors (& points , & n_points , & box , & periodic , & device , & options , & neighbors , & error_message & ) result ( status ) bind ( c , name = \"vesin_neighbors\" ) import :: c_double , c_size_t , c_bool , c_ptr , c_int import :: VesinDevice , VesinOptions , VesinNeighborList !> Number of elements in the `points` array integer ( c_size_t ), value :: n_points !> Positions of all points in the system; real ( c_double ), intent ( in ) :: points ( 3 , n_points ) !> Bounding box for the system. If the system is non-periodic, !! this is ignored. This should contain the three vectors of the !! bounding box, one vector per column of the matrix. real ( c_double ), intent ( in ) :: box ( 3 , 3 ) !> Is the system using periodic boundary conditions? This !! should be an array of three booleans, one for each dimension. logical ( c_bool ) :: periodic ( 3 ) !> Device where the `points` and `box` data is allocated. type ( VesinDevice ), value :: device !> Options for the calculation type ( VesinOptions ), value :: options !> A `type(VesinNeighborList)` instance, that will be used !! to store the computed list of neighbors. type ( VesinNeighborList ) :: neighbors !> A `type(c_ptr)` to a null-terminated `char*` containing the !! error message of this function if any. type ( c_ptr ), intent ( in ) :: error_message !> Non-zero integer upon error; zero otherwise. integer ( c_int ) :: status end function vesin_neighbors end interface !> Free all allocated memory inside a `VesinNeighborList`, according to it's !! `device`. interface subroutine vesin_free ( neighbors ) bind ( C , name = \"vesin_free\" ) import :: VesinNeighborList type ( VesinNeighborList ) :: neighbors end subroutine vesin_free end interface contains end module vesin_c","tags":"","url":"sourcefile/cdef.f90.html"}]}